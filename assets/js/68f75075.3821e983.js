"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4779],{8453(e,n,l){l.d(n,{R:()=>i,x:()=>s});var t=l(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},9517(e,n,l){l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"mutability/introduction","title":"Immutable vs Mutable Colors","description":"Negarity Color provides two color classes: Color (immutable) and MutableColor (mutable). Understanding the difference helps you choose the right one for your use case.","source":"@site/docs/mutability/introduction.md","sourceDirName":"mutability","slug":"/mutability/introduction","permalink":"/negarity-color/docs/mutability/introduction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Immutable vs Mutable Colors","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Named Colors","permalink":"/negarity-color/docs/named-colors/introduction"},"next":{"title":"Introduction to Extractors","permalink":"/negarity-color/docs/extractors-analysis/introduction"}}');var r=l(4848),o=l(8453);const i={title:"Immutable vs Mutable Colors",sidebar_position:1},s="Immutable vs Mutable Colors",a={},c=[{value:"Default: Immutable Color",id:"default-immutable-color",level:2},{value:"Benefits of Immutability",id:"benefits-of-immutability",level:3},{value:"Example with Immutable Color",id:"example-with-immutable-color",level:3},{value:"All Operations Return New Instances",id:"all-operations-return-new-instances",level:3},{value:"MutableColor: When You Need Mutability",id:"mutablecolor-when-you-need-mutability",level:2},{value:"When to Use MutableColor",id:"when-to-use-mutablecolor",level:3},{value:"Example with MutableColor",id:"example-with-mutablecolor",level:3},{value:"Using setChannel()",id:"using-setchannel",level:3},{value:"Chaining with MutableColor",id:"chaining-with-mutablecolor",level:3},{value:"Key Differences",id:"key-differences",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Immutable: Creating Color Variants",id:"immutable-creating-color-variants",level:3},{value:"Mutable: Iterative Color Processing",id:"mutable-iterative-color-processing",level:3},{value:"Mutable: Performance-Critical Operations",id:"mutable-performance-critical-operations",level:3},{value:"Converting Between Types",id:"converting-between-types",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Use Immutable Color When:",id:"use-immutable-color-when",level:3},{value:"Use MutableColor When:",id:"use-mutablecolor-when",level:3},{value:"Important Notes",id:"important-notes",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"immutable-vs-mutable-colors",children:"Immutable vs Mutable Colors"})}),"\n",(0,r.jsxs)(n.p,{children:["Negarity Color provides two color classes: ",(0,r.jsx)(n.code,{children:"Color"})," (immutable) and ",(0,r.jsx)(n.code,{children:"MutableColor"})," (mutable). Understanding the difference helps you choose the right one for your use case."]}),"\n",(0,r.jsx)(n.h2,{id:"default-immutable-color",children:"Default: Immutable Color"}),"\n",(0,r.jsxs)(n.p,{children:["By default, the ",(0,r.jsx)(n.code,{children:"Color"})," class is ",(0,r.jsx)(n.strong,{children:"immutable"}),", meaning that all operations return a new ",(0,r.jsx)(n.code,{children:"Color"})," instance rather than modifying the existing one. This is the recommended approach for most use cases."]}),"\n",(0,r.jsx)(n.h3,{id:"benefits-of-immutability",children:"Benefits of Immutability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prevents accidental mutations"}),": Original colors remain unchanged"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easier to reason about"}),": No side effects from operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Supports functional programming"}),": Pure functions without side effects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-safe"}),": Can be safely shared between contexts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Predictable"}),": Methods always return new instances"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-with-immutable-color",children:"Example with Immutable Color"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:'use Negarity\\Color\\Color;\n\n$color = Color::rgb(255, 100, 50);\n$modified = $color->with([\'r\' => 200]); // Returns a NEW Color instance\n\necho $color; // Still "rgb(255, 100, 50)" - original unchanged\necho $modified; // "rgb(200, 100, 50)" - new instance\n'})}),"\n",(0,r.jsx)(n.h3,{id:"all-operations-return-new-instances",children:"All Operations Return New Instances"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:'$color = Color::rgb(255, 100, 50);\n\n// Conversion returns new instance\n$hsl = $color->toHSL();\necho $color; // Still "rgb(255, 100, 50)"\necho $hsl; // "hsl(15, 100, 60)"\n\n// Modification returns new instance\n$lighter = $color->with([\'r\' => 200, \'g\' => 150]);\necho $color; // Still "rgb(255, 100, 50)"\necho $lighter; // "rgb(200, 150, 50)"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"mutablecolor-when-you-need-mutability",children:"MutableColor: When You Need Mutability"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"MutableColor"})," class provides a ",(0,r.jsx)(n.strong,{children:"mutable"})," alternative where operations modify the instance in place. This can be useful in specific scenarios."]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-mutablecolor",children:"When to Use MutableColor"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),": When you need to perform many operations on a single color object"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory efficiency"}),": When creating many new instances would be wasteful"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Iterative modifications"}),": When you're repeatedly modifying the same color object"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State management"}),": When the color object represents changing state"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-with-mutablecolor",children:"Example with MutableColor"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\MutableColor;\nuse Negarity\\Color\\ColorSpace\\RGB;\n\n$color = new MutableColor(RGB::class, ['r' => 255, 'g' => 100, 'b' => 50]);\n$color->with(['r' => 200]); // Modifies the SAME instance\n\necho $color; // \"rgb(200, 100, 50)\" - original was modified\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-setchannel",children:"Using setChannel()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"MutableColor"})," provides a ",(0,r.jsx)(n.code,{children:"setChannel()"})," method for direct channel modification:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"$color = new MutableColor(RGB::class, ['r' => 255, 'g' => 100, 'b' => 50]);\n\n// Directly set channel values\n$color->setChannel('r', 200);\n$color->setChannel('g', 150);\n\necho $color; // \"rgb(200, 150, 50)\"\n"})}),"\n",(0,r.jsx)(n.h3,{id:"chaining-with-mutablecolor",children:"Chaining with MutableColor"}),"\n",(0,r.jsxs)(n.p,{children:["Since ",(0,r.jsx)(n.code,{children:"MutableColor"})," methods return ",(0,r.jsx)(n.code,{children:"$this"}),", you can chain operations:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"$color = new MutableColor(RGB::class, ['r' => 255, 'g' => 100, 'b' => 50]);\n\n$color->with(['r' => 200])\n      ->toHSL()\n      ->with(['l' => 60])\n      ->toRGB();\n\necho $color; // Modified through the chain\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-differences",children:"Key Differences"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Color (Immutable)"}),(0,r.jsx)(n.th,{children:"MutableColor"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Operations"})}),(0,r.jsx)(n.td,{children:"Returns new instance"}),(0,r.jsx)(n.td,{children:"Modifies in place"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"with()"})," method"]})}),(0,r.jsx)(n.td,{children:"Returns new Color"}),(0,r.jsx)(n.td,{children:"Returns self (for chaining)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"without()"})," method"]})}),(0,r.jsx)(n.td,{children:"Returns new Color"}),(0,r.jsx)(n.td,{children:"Returns self (for chaining)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Conversion methods"})}),(0,r.jsx)(n.td,{children:"Returns new Color"}),(0,r.jsx)(n.td,{children:"Returns self (modifies instance)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"setChannel()"})})}),(0,r.jsx)(n.td,{children:"Not available"}),(0,r.jsx)(n.td,{children:"Available"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Memory usage"})}),(0,r.jsx)(n.td,{children:"Creates new objects"}),(0,r.jsx)(n.td,{children:"Reuses same object"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Thread safety"})}),(0,r.jsx)(n.td,{children:"Safe"}),(0,r.jsx)(n.td,{children:"Not thread-safe"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Side effects"})}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:"Modifies state"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,r.jsx)(n.h3,{id:"immutable-creating-color-variants",children:"Immutable: Creating Color Variants"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\Color;\n\n$baseColor = Color::rgb(255, 100, 50);\n\n// Create multiple variants without affecting original\n$variant1 = $baseColor->with(['r' => 200]);\n$variant2 = $baseColor->with(['g' => 150]);\n$variant3 = $baseColor->toHSL()->with(['l' => 70])->toRGB();\n\n// Original is still unchanged\necho $baseColor; // \"rgb(255, 100, 50)\"\n"})}),"\n",(0,r.jsx)(n.h3,{id:"mutable-iterative-color-processing",children:"Mutable: Iterative Color Processing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\MutableColor;\nuse Negarity\\Color\\ColorSpace\\RGB;\n\n$color = new MutableColor(RGB::class, ['r' => 255, 'g' => 100, 'b' => 50]);\n\n// Process color through multiple steps\nfor ($i = 0; $i < 10; $i++) {\n    $color->toHSL()\n          ->with(['l' => $color->getL() + 5])\n          ->toRGB();\n}\n\n// Single object modified multiple times\necho $color;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"mutable-performance-critical-operations",children:"Mutable: Performance-Critical Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\MutableColor;\nuse Negarity\\Color\\ColorSpace\\RGB;\n\n// When you need to modify a color many times\n$color = new MutableColor(RGB::class, ['r' => 255, 'g' => 100, 'b' => 50]);\n\n// Many operations without creating new objects\nfor ($i = 0; $i < 1000; $i++) {\n    $color->setChannel('r', $color->getR() - 1);\n    // Process color...\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"converting-between-types",children:"Converting Between Types"}),"\n",(0,r.jsx)(n.p,{children:"You can convert between immutable and mutable colors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\Color;\nuse Negarity\\Color\\MutableColor;\n\n// Start with immutable\n$immutable = Color::rgb(255, 100, 50);\n\n// Convert to mutable (create new MutableColor instance)\n$mutable = new MutableColor(\n    $immutable->getColorSpace(),\n    $immutable->getChannels()\n);\n\n// Or start with mutable and create immutable\n$mutable = new MutableColor(RGB::class, ['r' => 255, 'g' => 100, 'b' => 50]);\n$immutable = Color::rgb($mutable->getR(), $mutable->getG(), $mutable->getB());\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"use-immutable-color-when",children:"Use Immutable Color When:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Building most applications"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Working with color palettes or collections"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Passing colors between functions"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Need thread safety"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Want predictable, side-effect-free code"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"use-mutablecolor-when",children:"Use MutableColor When:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Performance is critical and you're doing many operations"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Working with a single color that changes over time"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Memory is constrained"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 You understand the implications of mutability"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Default to Immutable"}),": Unless you have a specific need for mutability, use the immutable ",(0,r.jsx)(n.code,{children:"Color"})," class"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Mixing"}),": Don't mix mutable and immutable colors in the same workflow without understanding the implications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread Safety"}),": ",(0,r.jsx)(n.code,{children:"MutableColor"})," is not thread-safe - don't share mutable color instances between threads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Management"}),": Be careful with mutable colors in complex state management scenarios"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Review the ",(0,r.jsx)(n.a,{href:"/docs/basics/creating-colors",children:"Basics"})," section for more on working with colors"]}),"\n",(0,r.jsxs)(n.li,{children:["Learn about ",(0,r.jsx)(n.a,{href:"/docs/filters/introduction",children:"Filters"})," for color transformations"]}),"\n",(0,r.jsxs)(n.li,{children:["Explore ",(0,r.jsx)(n.a,{href:"/docs/extending/color-spaces",children:"Extending the Library"})," to add custom functionality"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);