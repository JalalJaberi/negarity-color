"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2546],{8453(e,n,o){o.d(n,{R:()=>a,x:()=>t});var r=o(6540);const l={},s=r.createContext(l);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),r.createElement(s.Provider,{value:n},e.children)}},9078(e,n,o){o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>t,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extending/color-spaces","title":"Adding New Color Spaces","description":"This guide shows you how to extend Negarity Color by adding custom color spaces using the pluggable registry system.","source":"@site/docs/extending/color-spaces.md","sourceDirName":"extending","slug":"/extending/color-spaces","permalink":"/negarity-color/sv/docs/extending/color-spaces","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Adding New Color Spaces","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Exceptions Reference","permalink":"/negarity-color/sv/docs/references/exceptions"},"next":{"title":"Adding Color Names","permalink":"/negarity-color/sv/docs/extending/color-names"}}');var l=o(4848),s=o(8453);const a={title:"Adding New Color Spaces",sidebar_position:1},t="Adding New Color Spaces",i={},c=[{value:"Overview",id:"overview",level:2},{value:"Step 1: Create the Color Space Class",id:"step-1-create-the-color-space-class",level:2},{value:"Important Notes",id:"important-notes",level:3},{value:"Step 2: Register the Color Space",id:"step-2-register-the-color-space",level:2},{value:"Step 3: Use Your Color Space",id:"step-3-use-your-color-space",level:2},{value:"Step 4: Optional - Add Direct Conversion Methods",id:"step-4-optional---add-direct-conversion-methods",level:2},{value:"CIE Standard Support (Optional)",id:"cie-standard-support-optional",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Important Notes",id:"important-notes-1",level:2},{value:"Testing Your Color Space",id:"testing-your-color-space",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"adding-new-color-spaces",children:"Adding New Color Spaces"})}),"\n",(0,l.jsx)(n.p,{children:"This guide shows you how to extend Negarity Color by adding custom color spaces using the pluggable registry system."}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(n.p,{children:"To add a new color space, you need to:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Create a color space class implementing ",(0,l.jsx)(n.code,{children:"ColorSpaceInterface"})]}),"\n",(0,l.jsxs)(n.li,{children:["Implement required conversion methods (",(0,l.jsx)(n.code,{children:"toRGB()"})," and ",(0,l.jsx)(n.code,{children:"fromRGB()"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:["Register the color space with ",(0,l.jsx)(n.code,{children:"ColorSpaceRegistry"})]}),"\n",(0,l.jsx)(n.li,{children:"Optionally implement additional conversion methods for direct conversions"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Once registered, your color space will work seamlessly with all existing functionality:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Factory methods (e.g., ",(0,l.jsx)(n.code,{children:"Color::myCustom()"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:["Conversion methods (e.g., ",(0,l.jsx)(n.code,{children:"$color->toMyCustom()"}),")"]}),"\n",(0,l.jsx)(n.li,{children:"Filters (via RGB fallback)"}),"\n",(0,l.jsx)(n.li,{children:"Named colors"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"step-1-create-the-color-space-class",children:"Step 1: Create the Color Space Class"}),"\n",(0,l.jsxs)(n.p,{children:["Create a new class extending ",(0,l.jsx)(n.code,{children:"AbstractColorSpace"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"<?php\n\nnamespace MyApp\\ColorSpace;\n\nuse Negarity\\Color\\ColorSpace\\AbstractColorSpace;\nuse Negarity\\Color\\Exception\\InvalidColorValueException;\nuse Negarity\\Color\\CIE\\CIEIlluminant;\nuse Negarity\\Color\\CIE\\CIEObserver;\n\nfinal class MyCustomColorSpace extends AbstractColorSpace\n{\n    public static function getName(): string\n    {\n        return 'mycustom'; // Lowercase, no spaces - must be unique\n    }\n\n    public static function getChannels(): array\n    {\n        return ['channel1', 'channel2', 'channel3'];\n    }\n\n    public static function hasChannel(string $name): bool\n    {\n        return in_array($name, ['channel1', 'channel2', 'channel3'], true);\n    }\n\n    public static function getChannelDefaultValue(string $name): float\n    {\n        return match ($name) {\n            'channel1', 'channel2', 'channel3' => 0.0,\n            default => throw new InvalidColorValueException(\n                \"Channel '{$name}' does not exist in mycustom color space.\"\n            ),\n        };\n    }\n\n    public static function validateValue(string $channel, float $value): void\n    {\n        match ($channel) {\n            'channel1', 'channel2', 'channel3' => static::assertRange(\n                $value, \n                0.0, \n                100.0, \n                $channel\n            ),\n            default => throw new InvalidColorValueException(\n                \"Channel '{$channel}' does not exist in mycustom color space.\"\n            ),\n        };\n    }\n\n    #[\\Override]\n    public static function clampValue(string $channel, float $value): float\n    {\n        return match ($channel) {\n            'channel1', 'channel2', 'channel3' => static::clampRange($value, 0.0, 100.0),\n            default => throw new InvalidColorValueException(\n                \"Channel '{$channel}' does not exist in mycustom color space.\"\n            ),\n        };\n    }\n\n    /**\n     * Convert from this color space to RGB.\n     * This is REQUIRED for all color spaces.\n     * \n     * @param array<string, float> $values Color values in this space\n     * @param CIEIlluminant|null $illuminant Optional CIE illuminant (if supported)\n     * @param CIEObserver|null $observer Optional CIE observer (if supported)\n     * @return array<string, float> RGB values: ['r' => float, 'g' => float, 'b' => float]\n     */\n    public static function toRGB(\n        array $values,\n        ?CIEIlluminant $illuminant = null,\n        ?CIEObserver $observer = null\n    ): array {\n        $c1 = $values['channel1'] ?? 0.0;\n        $c2 = $values['channel2'] ?? 0.0;\n        $c3 = $values['channel3'] ?? 0.0;\n\n        // Your conversion logic here\n        // Example: simple linear conversion\n        $r = max(0.0, min(255.0, $c1 * 2.55));\n        $g = max(0.0, min(255.0, $c2 * 2.55));\n        $b = max(0.0, min(255.0, $c3 * 2.55));\n\n        return [\n            'r' => $r,\n            'g' => $g,\n            'b' => $b,\n        ];\n    }\n\n    /**\n     * Convert from RGB to this color space.\n     * This is REQUIRED for all color spaces.\n     * \n     * @param array<string, float> $values RGB values: ['r' => float, 'g' => float, 'b' => float]\n     * @param int $alpha Optional alpha channel (0-255, default: 255)\n     * @param CIEIlluminant|null $illuminant Optional CIE illuminant (if supported)\n     * @param CIEObserver|null $observer Optional CIE observer (if supported)\n     * @return array<string, float> Color values in this space\n     */\n    public static function fromRGB(\n        array $values,\n        int $alpha = 255,\n        ?CIEIlluminant $illuminant = null,\n        ?CIEObserver $observer = null\n    ): array {\n        $r = $values['r'] ?? 0.0;\n        $g = $values['g'] ?? 0.0;\n        $b = $values['b'] ?? 0.0;\n\n        // Your conversion logic here\n        // Example: simple linear conversion\n        $c1 = max(0.0, min(100.0, $r / 2.55));\n        $c2 = max(0.0, min(100.0, $g / 2.55));\n        $c3 = max(0.0, min(100.0, $b / 2.55));\n\n        return [\n            'channel1' => $c1,\n            'channel2' => $c2,\n            'channel3' => $c3,\n        ];\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"important-notes",children:"Important Notes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Channel values are always floats"}),": All channel values must be ",(0,l.jsx)(n.code,{children:"float"})," type for precision"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"toRGB()"})," and ",(0,l.jsx)(n.code,{children:"fromRGB()"})," are required"]}),": These methods enable automatic conversions through RGB"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsxs)(n.strong,{children:[(0,l.jsx)(n.code,{children:"clampValue()"})," is required"]}),": This method is used to clamp values to valid ranges"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Clamp values"}),": Always clamp converted values to valid ranges to prevent invalid colors"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Return types"}),": Both methods must return ",(0,l.jsx)(n.code,{children:"array<string, float>"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Clamping responsibility"}),": Color spaces are responsible for clamping values. The clamping system automatically uses ",(0,l.jsx)(n.code,{children:"clampValue()"})," when needed."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"step-2-register-the-color-space",children:"Step 2: Register the Color Space"}),"\n",(0,l.jsxs)(n.p,{children:["Register your color space with the ",(0,l.jsx)(n.code,{children:"ColorSpaceRegistry"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\Registry\\ColorSpaceRegistry;\nuse MyApp\\ColorSpace\\MyCustomColorSpace;\n\n// Register your custom color space\nColorSpaceRegistry::register(MyCustomColorSpace::class);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"step-3-use-your-color-space",children:"Step 3: Use Your Color Space"}),"\n",(0,l.jsx)(n.p,{children:"Once registered, your color space works automatically:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\Color;\nuse Negarity\\Color\\Registry\\ColorSpaceRegistry;\nuse MyApp\\ColorSpace\\MyCustomColorSpace;\n\n// Register the color space\nColorSpaceRegistry::register(MyCustomColorSpace::class);\n\n// Create colors using factory method (works automatically!)\n$color = Color::mycustom(50.0, 60.0, 70.0);\n\n// Convert to other color spaces\n$rgb = $color->toRGB();\n$hsl = $color->toHSL();\n$cmyk = $color->toCMYK();\n\n// Convert from other color spaces\n$fromRgb = Color::rgb(255, 100, 50)->toMyCustom();\n$fromHsl = Color::hsl(210, 50, 40)->toMyCustom();\n\n// Use with filters (automatically converts via RGB)\n$brightened = $color->brightness(20);\n"})}),"\n",(0,l.jsx)(n.h2,{id:"step-4-optional---add-direct-conversion-methods",children:"Step 4: Optional - Add Direct Conversion Methods"}),"\n",(0,l.jsx)(n.p,{children:"For better performance, you can add direct conversion methods to avoid going through RGB. These are optional but recommended:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"// In MyCustomColorSpace class\n\n/**\n * Convert from HSL to this color space (direct conversion, optional).\n * If not implemented, conversion will go through RGB.\n */\npublic static function fromHSL(array $values): array\n{\n    // Direct conversion logic from HSL\n    // ...\n}\n\n/**\n * Convert from this color space to HSL (direct conversion, optional).\n * If not implemented, conversion will go through RGB.\n */\npublic static function toHSL(array $values): array\n{\n    // Direct conversion logic to HSL\n    // ...\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"When you implement these methods, they will be automatically used instead of the RGB fallback."}),"\n",(0,l.jsx)(n.h2,{id:"cie-standard-support-optional",children:"CIE Standard Support (Optional)"}),"\n",(0,l.jsx)(n.p,{children:"If your color space supports CIE Standard Illuminants and Observers, implement these methods:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"public static function supportsIlluminant(): bool\n{\n    return true; // or false\n}\n\npublic static function supportsObserver(): bool\n{\n    return true; // or false\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Then use the ",(0,l.jsx)(n.code,{children:"$illuminant"})," and ",(0,l.jsx)(n.code,{children:"$observer"})," parameters in your ",(0,l.jsx)(n.code,{children:"toRGB()"})," and ",(0,l.jsx)(n.code,{children:"fromRGB()"})," methods."]}),"\n",(0,l.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,l.jsx)(n.p,{children:'Here\'s a complete example for a hypothetical "XYZ2" color space:'}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"<?php\n\nnamespace MyApp\\ColorSpace;\n\nuse Negarity\\Color\\ColorSpace\\AbstractColorSpace;\nuse Negarity\\Color\\Exception\\InvalidColorValueException;\n\nfinal class XYZ2 extends AbstractColorSpace\n{\n    public static function getName(): string\n    {\n        return 'xyz2';\n    }\n\n    public static function getChannels(): array\n    {\n        return ['x', 'y', 'z'];\n    }\n\n    public static function hasChannel(string $name): bool\n    {\n        return in_array($name, ['x', 'y', 'z'], true);\n    }\n\n    public static function getChannelDefaultValue(string $name): float\n    {\n        return match ($name) {\n            'x', 'y', 'z' => 0.0,\n            default => throw new InvalidColorValueException(\n                \"Channel '{$name}' does not exist in xyz2 color space.\"\n            ),\n        };\n    }\n\n    public static function validateValue(string $channel, float $value): void\n    {\n        if (!is_numeric($value)) {\n            throw new InvalidColorValueException(\n                \"Channel '{$channel}' must be numeric.\"\n            );\n        }\n    }\n\n    public static function toRGB(\n        array $values,\n        ?\\Negarity\\Color\\CIE\\CIEIlluminant $illuminant = null,\n        ?\\Negarity\\Color\\CIE\\CIEObserver $observer = null\n    ): array {\n        $x = $values['x'] ?? 0.0;\n        $y = $values['y'] ?? 0.0;\n        $z = $values['z'] ?? 0.0;\n\n        // Your conversion matrix here\n        // Example conversion (simplified)\n        $r = max(0.0, min(255.0, $x * 2.55));\n        $g = max(0.0, min(255.0, $y * 2.55));\n        $b = max(0.0, min(255.0, $z * 2.55));\n\n        return ['r' => $r, 'g' => $g, 'b' => $b];\n    }\n\n    public static function fromRGB(\n        array $values,\n        int $alpha = 255,\n        ?\\Negarity\\Color\\CIE\\CIEIlluminant $illuminant = null,\n        ?\\Negarity\\Color\\CIE\\CIEObserver $observer = null\n    ): array {\n        $r = $values['r'] ?? 0.0;\n        $g = $values['g'] ?? 0.0;\n        $b = $values['b'] ?? 0.0;\n\n        // Your conversion matrix here\n        // Example conversion (simplified)\n        $x = max(0.0, min(100.0, $r / 2.55));\n        $y = max(0.0, min(100.0, $g / 2.55));\n        $z = max(0.0, min(100.0, $b / 2.55));\n\n        return ['x' => $x, 'y' => $y, 'z' => $z];\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"Register and use:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:"use Negarity\\Color\\Color;\nuse Negarity\\Color\\Registry\\ColorSpaceRegistry;\nuse MyApp\\ColorSpace\\XYZ2;\n\n// Register\nColorSpaceRegistry::register(XYZ2::class);\n\n// Use\n$color = Color::xyz2(20.0, 30.0, 40.0);\n$rgb = $color->toRGB();\n"})}),"\n",(0,l.jsx)(n.h2,{id:"important-notes-1",children:"Important Notes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Color space names"})," must be lowercase and unique"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Channel validation"})," is important for data integrity"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Conversion accuracy"})," depends on your conversion algorithms"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Default values"}),' should represent "no color" or "black" for your space']}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Range validation"})," prevents invalid color values"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"All values are floats"}),": Channel values are always ",(0,l.jsx)(n.code,{children:"float"})," type for precision"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"RGB is the hub"}),": All conversions go through RGB if direct methods aren't available"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"testing-your-color-space",children:"Testing Your Color Space"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-php",children:'use Negarity\\Color\\Color;\nuse Negarity\\Color\\Registry\\ColorSpaceRegistry;\nuse MyApp\\ColorSpace\\XYZ2;\n\n// Register\nColorSpaceRegistry::register(XYZ2::class);\n\n// Create color in your space\n$color = Color::xyz2(50.0, 60.0, 70.0);\n\n// Convert to RGB\n$rgb = $color->toRGB();\necho $rgb; // "rgb(...)"\n\n// Convert back\n$xyz2 = $rgb->toXyz2();\necho $xyz2; // "xyz2(...)"\n\n// Test round-trip conversion\n$original = Color::xyz2(50.0, 60.0, 70.0);\n$converted = $original->toRGB()->toXyz2();\n// Values should be close (may have slight precision differences)\n'})}),"\n",(0,l.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/references/color-spaces",children:"Color Spaces Reference"})," - See existing color spaces"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/basics/converting-colors",children:"Converting Colors"})," - Understand conversions"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/references/methods",children:"Color Space Registry API"})," - Registry methods"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);